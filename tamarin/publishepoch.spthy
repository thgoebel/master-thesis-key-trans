/*
This file contains the Email Address Key generation, the VKD.Publish,
and the ProtonVKD.VerifyEpoch subprotocols
*/

/* ------- VKD.Publish ------- */

// TODO: distinguish between the normal keylist and the not-yet-included keylist?
// TODO: pk/sk
rule ClientKeyGen:
    let keys_new = keys ++ ~newkey
        keys_rev_new = %keys_rev %+ %1
    in
    [ Fr(~newkey)
    , St_Client(id, $email, keys, %keys_rev) ]
    --[
        ClientKeyGen($email, keys, keys_new)
      , RequestInsertion($email, keys_new)
    ]->
    [ St_Client(id, $email, keys_new, keys_rev_new)
    , Out(<'insert', $email, ~newkey>) ]
    // XXX: Tamarin has troubles with the below (partial deconstructions).
    //      As a workaround, only send the newkey instead of the entire keylist
    //      (i.e. the client can have at most one key at a time).
    //, Out(<'insert', $email, keys_new>) ]

// TODO: model aggregation into batches (instead of one epoch per key)
rule ReceiveInsertAndIssueEpoch[color=#6d4af6]:
    let epoch_id_new = %latest_epoch_id %+ %1
        roothash_new = 'todo'
        chainhash_new = h(<chainhash_old, roothash_new>)
        sig_new = sign(<epoch_id_new, chainhash_new>, sk)
    in
    [ In(<'insert', email, keys>)
    , !SST_Epoch(%latest_epoch_id, chainhash_old, roothash_old, sig_old)
    , St_Server(id, sk, %latest_epoch_id) ]
    --[
        IssueEpoch(epoch_id_new, chainhash_new, roothash_new)
      , IssueEpochForInsertion(epoch_id_new, chainhash_new, email, keys)
      , Insert(email, keys)
      , ServerEpochSign(id, epoch_id_new, sig_new)
    ]->
    [ St_Server(id, sk, epoch_id_new)
    , !CT(epoch_id_new, chainhash_new, sig_new)
    , !SST_Directory(email, epoch_id_new, keys, %1)  // TODO: val_rev
    , !SST_Epoch(epoch_id_new, chainhash_new, roothash_new, sig_new) ]


/* ------- ProtonVKD.VerifyEpoch ------- */

// This client-side algorithm only checks that an epoch and its roothash
// are correctly logged on a magic bulletin board.
// Keybase uses a blockchain as the bulletin board, Proton uses CT.
//
// All other epoch-related checks (correct epoch-to-epoch chaining, unique epochs,
// append-only-ness, etc.) are delegated to the auditors.
// I.e. this does NOT detect equivocation - a separate audit of CT is needed!
//
// Inputs:
// - the epoch_id of the epoch that should be checked against CT
// - the expected root_hash (we have this from an inclusion proof)
//
// Steps:
// 1. Ask the server for the PrevChainHash. Use that to construct the ChainHash.
// 2. Check that the <EpochId, ChainHash> are logged in CT.
//
// Note that the "PrevChainHash" is provided by the server.
// So it is more of a sanity check, and doesn't give real security.
// UNLESS the clients locally stores a DB of chain hashes (which it currently doesn't?).

rule VerifyEpoch_1[color=#f9d949]:
    // The "stack" is used to cache variables that VKD.VerifyEpoch ignores,
    // but that the caller needs to get back.
    // It should be a tuple <'callername', data> so that there is no type confusion in the data.
    [ St_Client_VerifyEpoch0(id, email, keys, keys_rev, %epoch_id_to_verify, expected_root_hash, stack) ]
    -->
    [ St_Client_VerifyEpoch1(id, email, keys, keys_rev, %epoch_id_to_verify, expected_root_hash, stack)
    , Out(<'ve1', %epoch_id_to_verify>) ]

// curl 'https://mail.proton.me/api/kt/v1/epochs/300' | jq
// TODO: the API does not return any signature
// TODO: infinite loop troubles -- interestingly they (1) started with 37fef0168617 and (2) occur when proving Executability_Query ???
rule VerifyEpoch_2[color=#f9d949]:
    let epoch_id_verify = %epoch_id_verify_prev %+ %1 // workaround for %-
    in
    [ In(<'ve1', %epoch_id_verify>)
    , !SST_Epoch(%epoch_id_verify, chainhash_verify, roothash_verify, sig_verify)
    , !SST_Epoch(%epoch_id_prev, chainhash_prev, roothash_prev, sig_prev)
    ]//, St_Server(id, sk, latest_epoch_id) ]
    -->
    //[ St_Server(id, sk, latest_epoch_id)
    [ Out(<'ve2', chainhash_prev, chainhash_verify, roothash_verify>) ]

rule VerifyEpoch_3[color=#f9d949]:
    let chainhash_new_computed = h(<chainhash_prev, expected_root_hash>)
    in
    [ In(<'ve2', chainhash_prev, chainhash_verify, roothash_verify>)
    // make the CT chainhash explictly different and check for equality below
    // (for clarity when comparing against the implementation)
    // TODO: model certificate and SCT in detail?
    , !CT(epoch_id_to_verify, chainhash_ct, sig)
    , St_Client_VerifyEpoch1(id, email, keys, keys_rev, epoch_id_to_verify, expected_root_hash, stack) ]
    --[
        Eq(expected_root_hash, roothash_verify)
      , Eq(chainhash_new_computed, chainhash_verify)
      , Eq(chainhash_new_computed, chainhash_ct)
      , EpochVerified(epoch_id_to_verify, chainhash_new_computed)
      // TODO: verify CT signature?
    ]->
    [ St_Client_VerifyEpoch_Done(id, email, keys, keys_rev, epoch_id_to_verify, expected_root_hash, stack) ]


/* ------- Audit CT ------- */

rule Audit_CT_Equivocation[color=#eb508d]:
    [ !CT(epoch_id, chainhash_ct_1, sig_1)
    , !CT(epoch_id, chainhash_ct_2, sig_2)
    , !Pk($server, pk) ]
    --[
        Neq(chainhash_ct_1, chainhash_ct_2)
      , Eq(verify(sig_1, <epoch_id, chainhash_ct_1>, pk), true)
      , Eq(verify(sig_2, <epoch_id, chainhash_ct_2>, pk), true)
      , EquivocationInCt(epoch_id)
    ]->
    []


/* ------- Executability (sanity check) Lemmas ------- */

// Tell Tamarin where "keys" could have come from
// TODO: doesn't work, still 9 partial deconstructions left
// TODO: use subterms??
// lemma Type_ClientKeyGen_Keys [use_induction,sources]:
//     all-traces
//     "All email prevkeylist newkeylist #i .
//         ClientKeyGen(email, prevkeylist, newkeylist)@i
//       ==> ( Ex prevprevkeylist #j . ClientKeyGen(email, prevprevkeylist, prevkeylist)@j & j < i )
//          | ( prevkeylist = 'empty')
//     "

lemma Executability_PublishEpoch:
    exists-trace
    "Ex email keys epoch_id chainhash #i #j .
        RequestInsertion(email, keys)@i
        & IssueEpochForInsertion(epoch_id, chainhash, email, keys)@j
        & i < j
    "

lemma Executability_VerifyEpoch:
    exists-trace
    "Ex epoch_id email keys chainhash #i #j .
        IssueEpochForInsertion(epoch_id, chainhash, email, keys)@i
        & EpochVerified(epoch_id, chainhash)@j
        & i < j
        & not (Ex #k . Adverserial_CT_Insert(epoch_id)@k )
    "

lemma Executability_ServerSignsOnlyOneChainhashPerEpochId:
    all-traces
    "All id epoch_id sig_1 #i .
        ServerEpochSign(id, epoch_id, sig_1)@i
    ==> not (Ex sig_2 #j . ServerEpochSign(id, epoch_id, sig_2)@j & not (sig_1 = sig_2))
    "

/* ------- Security Lemmas ------- */

// Helper needed to prove "Security_NonDiscreditabilityCT"
//
// Intuition:
// During "Security_NonDiscreditabilityCT" Tamarin searches a path where it creates many
// different servers, which then generate signatures and CT entries.
// By linking the ServerEpochSign to the InitServer, we implicitly link
// the signing back to a secret key.
// This helps Tamarin figure out that this is a dead-end:
// after all, the rule "Audit_CT_Equivocation" requires that they are signed by the same key.
lemma Helper_LinkEpochSignToInitServer[use_induction,reuse]:
    all-traces
    "All id e s #i .
        ServerEpochSign(id, e, s)@i
    ==> (InitServer(id)@i)
        | (Ex #j . InitServer(id)@j & j < i)
    "

lemma Security_NonDiscreditabilityCT:
    all-traces
    "All epoch_id #i . EquivocationInCt(epoch_id)@i
        ==> Ex #j . RevealServerSk()@j & j < i
    "
