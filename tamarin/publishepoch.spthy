/*
This file contains the Email Address Key generation, the VKD.Publish,
and the ProtonVKD.VerifyEpoch subprotocols
*/

/* ------- VKD.Publish ------- */

// TODO: distinguish between the normal keylist and the not-yet-included keylist?
// TODO: pk/sk
rule ClientKeyGen:
    let keys_new = keys ++ ~newkey
        keys_rev_new = %keys_rev %+ %1
    in
    [ Fr(~newkey)
    , St_Client(id, $email, keys, %keys_rev) ]
    --[
        ClientKeyGen($email, keys, keys_new)
      , RequestInsertion($email, keys_new)
    ]->
    [ St_Client(id, $email, keys_new, keys_rev_new)
    , Out(<'insert', $email, ~newkey>) ]
    // XXX: Tamarin has troubles with the below (partial deconstructions).
    //      As a workaround, only send the newkey instead of the entire keylist
    //      (i.e. the client can have at most one key at a time).
    //, Out(<'insert', $email, keys_new>) ]

// TODO: model aggregation into batches (instead of one epoch per key)
rule ReceiveInsertAndIssueEpoch[color=#6d4af6]:
    let epoch_id_new = %epoch_id_old %+ %1
        roothash_new = 'todo'
        chainhash_new = h(chainhash_old ++ roothash_new)
        sig = sign(<epoch_id_new, chainhash_new>, sk)
    in
    [ In(<'insert', email, keys>)
    , St_Server(id, sk, %epoch_id_old, chainhash_old, roothash_old) ]
    --[
        IssueEpoch(epoch_id_new, chainhash_new, roothash_new)
      , IssueEpochForInsertion(epoch_id_new, chainhash_new, email, keys)
      , Insert(email, keys)
    ]->
    [ St_Server(id, sk, epoch_id_new, chainhash_new, roothash_new)
    , !SST_Directory(email, epoch_id_new, keys, %1)  // TODO: val_rev
    , !SST_Epoch(epoch_id_new, chainhash_new, roothash_new, sig) ]

/* ------- ProtonVKD.VerifyEpoch ------- */

rule VerifyEpoch_1[color=#f9d949]:
    let epoch_id_new = %epoch_id_old %+ %1
    in
    [ St_Auditor(id, %epoch_id_old, chainhash_old) ]
    -->
    [ St_Auditor_VerifyEpoch1(id, %epoch_id_old, chainhash_old, epoch_id_new)
    , Out(<'ve1', epoch_id_new>) ]

// curl 'https://mail.proton.me/api/kt/v1/epochs/300' | jq
// TODO: the API does not include any signature
// XXX: We don't model all fields in the response, e.g. "PrevChainHash" is omitted.
rule VerifyEpoch_2[color=#f9d949]:
    [ In(<'ve1', %epoch_id_verify>)
    , !SST_Epoch(%epoch_id_verify, chainhash_verify, roothash_verify, sig)
    , St_Server(id, sk, epoch_id, chainhash, roothash) ]
    -->
    [ St_Server(id, sk, epoch_id, chainhash, roothash)
    , Out(<'ve2', chainhash_verify, roothash_verify>) ]

// Note: This algorithm does NOT check append-only-ness.
//       It only checks that chainhash_t is included in CT.
// TODO: check against magic bulletin board.
// TODO: model certificate and SCT.
rule VerifyEpoch_3[color=#f9d949]:
    let chainhash_new_computed = h(chainhash_old ++ roothash_new)
    in
    [ In(<'ve2', chainhash_new, roothash_new>)
    , St_Auditor_VerifyEpoch1(id, epoch_id_old, chainhash_old, epoch_id_new) ]
    --[
        Eq(chainhash_new_computed, chainhash_new)
      , EpochVerified(epoch_id_new, chainhash_new)
    ]->
    [ St_Auditor(id, epoch_id_new, chainhash_new)]


/* ------- Lemmas ------- */

// Tell Tamarin where "keys" could have come from
// TODO: doesn't work, still 9 partial deconstructions left
// TODO: use subterms??
// lemma Type_ClientKeyGen_Keys [use_induction,sources]:
//     all-traces
//     "All email prevkeylist newkeylist #i .
//         ClientKeyGen(email, prevkeylist, newkeylist)@i
//       ==> ( Ex prevprevkeylist #j . ClientKeyGen(email, prevprevkeylist, prevkeylist)@j & j < i )
//          | ( prevkeylist = 'empty')
//     "

lemma Executability_PublishEpoch:
    exists-trace
    "Ex email keys epoch_id chainhash #i #j .
        RequestInsertion(email, keys)@i
        & IssueEpochForInsertion(epoch_id, chainhash, email, keys)@j
        & i < j
    "

lemma Executability_VerifyEpoch:
    exists-trace
    "Ex epoch_id email keys chainhash #i #j .
        IssueEpochForInsertion(epoch_id, chainhash, email, keys)@i
        & EpochVerified(epoch_id, chainhash)@j
        & i < j
    "
