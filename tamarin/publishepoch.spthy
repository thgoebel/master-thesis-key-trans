/*
This file contains the Email Address Key generation, the VKD.Publish,
and the ProtonVKD.VerifyEpoch subprotocols
*/

/* ------- VKD.Publish ------- */

// TODO: distinguish between the normal keylist and the not-yet-included keylist?
// TODO: model keylists/keyrings rather than a single pk
// XXX: aggregation into batches (instead of one epoch per key) is not modelled
rule ClientKeyGen:
    let keys_new = keys ++ ~sk_new
        keys_rev_new = %keys_rev %+ %1
    in
    [ Fr(~sk_new)
    , St_Client(id, $email, keys, %keys_rev) ]
    --[
        RequestInsertion($email, pk(~sk_new))
    ]->
    [ St_Client(id, $email, keys_new, keys_rev_new)
    , Out(<$email, pk(~sk_new)>) ]


/* ------- Audit CT ------- */

rule Audit_CT_Equivocation[color=#eb508d]:
    [ !CT(epoch_id, chainhash_ct_1, sig_1)
    , !CT(epoch_id, chainhash_ct_2, sig_2)
    , !Pk($server, pk) ]
    --[
        Neq(chainhash_ct_1, chainhash_ct_2)
      , Eq(verify(sig_1, <epoch_id, chainhash_ct_1>, pk), true)
      , Eq(verify(sig_2, <epoch_id, chainhash_ct_2>, pk), true)
      , EquivocationInCt(epoch_id)
    ]->
    []


/* ------- Executability (sanity check) Lemmas ------- */

lemma Basic_Executability:
    exists-trace
    "Ex label val rev roothash #i #j #k .
          RequestInsertion(label, val)@i
        & Query(label)@j
        & QueryVerified(label, val, rev, roothash)@k
        & i < j
        & j < k
    "

// Check that the protocol can append to the user subtree
lemma Executability_NewRevision:
    exists-trace
    "Ex label val1 rev1 roothash1 ut1 #i1 #j1 #k1
              val2 rev2 roothash2 ut2 #i2 #j2 #k2 .
          RequestInsertion(label, val1)@i1
        & Query(label)@j1
        // & QueryVerified(label, val1, rev1, roothash1)@k1
        & QueryVerifiedUserTree(label, val1, rev1, roothash1, ut1)@k1
        & i1 < j1
        & j1 < k1
        & RequestInsertion(label, val2)@i2
        & Query(label)@j2
        // & QueryVerified(label, val2, rev2, roothash2)@k2
        & QueryVerifiedUserTree(label, val2, rev2, roothash2, ut2)@k2
        & i2 < j2
        & j2 < k2
        & not (val1 = val2)
        & rev1 << rev2
        & roothash1 << roothash2
        & ut1 << ut2
        // trim the example trace
        & not ( Ex val3 #i3 . RequestInsertion(label, val3)@i3 & not (val3 = val1 | val3 = val2) )
        & not ( Ex label3 val3 #i3 . RequestInsertion(label3, val3)@i3 & not (label3 = label) )
    "

// Check that the protocol can insert two distinct users into the same tree
lemma Executability_TwoLabelsInSameTree:
    exists-trace
    "Ex roothash label1 val1 rev1 #i1 #j1 #k1
                 label2 val2 rev2 #i2 #j2 #k2 .
          RequestInsertion(label1, val1)@i1
        & Query(label1)@j1
        & QueryVerified(label1, val1, rev1, roothash)@k1
        & i1 < j1
        & j1 < k1
        & RequestInsertion(label2, val2)@i2
        & Query(label2)@j2
        & QueryVerified(label2, val2, rev2, roothash)@k2
        & i2 < j2
        & j2 < k2
        & not (label1 = label2)
        & not (val1 = val2)
    "


/* ------- Security Lemmas ------- */

// Helper needed to prove "Security_NonDiscreditabilityCT"
//
// Intuition:
// During "Security_NonDiscreditabilityCT" Tamarin searches a path where it creates many
// different servers, which then generate signatures and CT entries.
// By linking the ServerEpochSign to the InitServer, we implicitly link
// the signing back to a secret key.
// This helps Tamarin figure out that this is a dead-end:
// after all, the rule "Audit_CT_Equivocation" requires that they are signed by the same key.
lemma Helper_LinkEpochSignToInitServer[use_induction,reuse]:
    all-traces
    "All id e s #i .
        ServerEpochSign(id, e, s)@i
    ==> (InitServer(id)@i)
        | (Ex #j . InitServer(id)@j & j < i)
    "

lemma Security_NonDiscreditabilityCT:
    all-traces
    "All epoch_id #i . EquivocationInCt(epoch_id)@i
        ==> Ex #j . RevealServerSk()@j & j < i
    "
