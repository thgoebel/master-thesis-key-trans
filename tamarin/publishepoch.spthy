/*
This file contains the Email Address Key generation, the VKD.Publish,
and the ProtonVKD.VerifyEpoch subprotocols
*/

/* ------- VKD.Publish ------- */

// TODO: distinguish between the normal keylist and the not-yet-included keylist?
// TODO: model keylists/keyrings rather than a single pk
rule ClientKeyGen:
    let keys_new = keys ++ ~sk_new
        keys_rev_new = %keys_rev %+ %1
    in
    [ Fr(~sk_new)
    , St_Client(id, $email, keys, %keys_rev) ]
    --[
        RequestInsertion($email, pk(~sk_new))
    ]->
    [ St_Client(id, $email, keys_new, keys_rev_new)
    , Out(<'insert', $email, pk(~sk_new)>) ]

// XXX: aggregation into batches (instead of one epoch per key) is not modelled
rule ReceiveInsertAndIssueEpoch[color=#6d4af6]:
    let epoch_id_new = %latest_epoch_id %+ %1
        roothash_new = 'todo'
        chainhash_new = h(<chainhash_old, roothash_new>)
        sig_new = sign(<epoch_id_new, chainhash_new>, sk)

        %rev_new = %rev_old %+ %1
    in
    [ In(<'insert', label, val>)
    , !TreeLeaf(label, val_old, %rev_old)
    , !SST_Epoch(%latest_epoch_id, chainhash_old, roothash_old, sig_old)
    , St_Server(id, sk, %latest_epoch_id) ]
    --[
        IssueEpoch(epoch_id_new, chainhash_new)
      , ServerEpochSign(id, epoch_id_new, sig_new)
      , Insert(label, val, %rev_new)
      , IsLatestRevision(label, %rev_old)
    ]->
    [ St_Server(id, sk, epoch_id_new)
    , !CT(epoch_id_new, chainhash_new, sig_new)
    , !TreeLeaf(label, val, %rev_new)
    , !SST_Epoch(epoch_id_new, chainhash_new, roothash_new, sig_new) ]

// Initialise the tree leaf for any label.
// This allows both absence proofs (TODO: implement)
// and it serves as the basis for the revision that is incremented with each key update.
//
// TODO: Model private index calculation with VRF (instead of using the label/email)
rule Init_Tree_Leaf:
    let val = 'emptyleaf'
        rev = %1
    in
    []
    --[
        Insert($label, val, rev)
      , OnlyOne($label) // restrict to only one initial leaf
    ]->
    [ !TreeLeaf($label, val, rev) ]


/* ------- Audit CT ------- */

rule Audit_CT_Equivocation[color=#eb508d]:
    [ !CT(epoch_id, chainhash_ct_1, sig_1)
    , !CT(epoch_id, chainhash_ct_2, sig_2)
    , !Pk($server, pk) ]
    --[
        Neq(chainhash_ct_1, chainhash_ct_2)
      , Eq(verify(sig_1, <epoch_id, chainhash_ct_1>, pk), true)
      , Eq(verify(sig_2, <epoch_id, chainhash_ct_2>, pk), true)
      , EquivocationInCt(epoch_id)
    ]->
    []


/* ------- Restrictions ------- */

restriction IsLatestRevision:
    "All label rev1 #i .
        IsLatestRevision(label, rev1)@i
        ==>
        not (Ex val2 rev2 #j .
                Insert(label, val2, rev2)@j
                & j < i
                & rev1 << rev2 & not (rev1 = rev2)
            )
    "


/* ------- Executability (sanity check) Lemmas ------- */

lemma Executability_PublishEpoch:
    exists-trace
    "Ex email keys rev #i #j .
        RequestInsertion(email, keys)@i
        & Insert(email, keys, rev)@j
        & i < j
    "

lemma Executability_ServerSignsOnlyOneChainhashPerEpochId:
    all-traces
    "All id epoch_id sig_1 #i .
        ServerEpochSign(id, epoch_id, sig_1)@i
    ==> not (Ex sig_2 #j . ServerEpochSign(id, epoch_id, sig_2)@j & not (sig_1 = sig_2))
    "

/* ------- Security Lemmas ------- */

// Helper needed to prove "Security_NonDiscreditabilityCT"
//
// Intuition:
// During "Security_NonDiscreditabilityCT" Tamarin searches a path where it creates many
// different servers, which then generate signatures and CT entries.
// By linking the ServerEpochSign to the InitServer, we implicitly link
// the signing back to a secret key.
// This helps Tamarin figure out that this is a dead-end:
// after all, the rule "Audit_CT_Equivocation" requires that they are signed by the same key.
lemma Helper_LinkEpochSignToInitServer[use_induction,reuse]:
    all-traces
    "All id e s #i .
        ServerEpochSign(id, e, s)@i
    ==> (InitServer(id)@i)
        | (Ex #j . InitServer(id)@j & j < i)
    "

lemma Security_NonDiscreditabilityCT:
    all-traces
    "All epoch_id #i . EquivocationInCt(epoch_id)@i
        ==> Ex #j . RevealServerSk()@j & j < i
    "
