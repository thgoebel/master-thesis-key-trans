/*
This file contains the Email Address Key generation, the VKD.Publish,
and the ProtonVKD.VerifyEpoch subprotocols
*/

/* ------- VKD.Publish ------- */

// TODO: distinguish between the normal keylist and the not-yet-included keylist?
// TODO: pk/sk
rule ClientKeyGen:
    let keys_new = keys ++ ~newkey
        keys_rev_new = %keys_rev %+ %1
    in
    [ Fr(~newkey)
    , St_Client(id, $email, keys, %keys_rev) ]
    --[
        ClientKeyGen($email, keys, keys_new)
      , RequestInsertion($email, keys_new)
    ]->
    [ St_Client(id, $email, keys_new, keys_rev_new)
    , Out(<'insert', $email, ~newkey>) ]
    // XXX: Tamarin has troubles with the below (partial deconstructions).
    //      As a workaround, only send the newkey instead of the entire keylist
    //      (i.e. the client can have at most one key at a time).
    //, Out(<'insert', $email, keys_new>) ]

// TODO: model aggregation into batches (instead of one epoch per key)
rule ReceiveInsertAndIssueEpoch[color=#6d4af6]:
    let epoch_id_new = %latest_epoch_id %+ %1
        roothash_new = 'todo'
        chainhash_new = h(chainhash_old ++ roothash_new)
        sig_new = sign(<epoch_id_new, chainhash_new>, sk)
    in
    [ In(<'insert', email, keys>)
    , !SST_Epoch(%latest_epoch_id, chainhash_old, roothash_old, sig_old)
    , St_Server(id, sk, %latest_epoch_id) ]
    --[
        IssueEpoch(epoch_id_new, chainhash_new, roothash_new)
      , IssueEpochForInsertion(epoch_id_new, chainhash_new, email, keys)
      , Insert(email, keys)
      , ServerEpochSign(id, epoch_id_new, sig_new)
    ]->
    [ St_Server(id, sk, epoch_id_new)
    , !CT(epoch_id_new, chainhash_new, sig_new)
    , !SST_Directory(email, epoch_id_new, keys, %1)  // TODO: val_rev
    , !SST_Epoch(epoch_id_new, chainhash_new, roothash_new, sig_new) ]


/* ------- ProtonVKD.VerifyEpoch ------- */

rule VerifyEpoch_1[color=#f9d949]:
    let epoch_id_new = %epoch_id_old %+ %1
    in
    [ St_Auditor(id, %epoch_id_old, chainhash_old) ]
    -->
    [ St_Auditor_VerifyEpoch1(id, %epoch_id_old, chainhash_old, epoch_id_new)
    , Out(<'ve1', epoch_id_new>) ]

// curl 'https://mail.proton.me/api/kt/v1/epochs/300' | jq
// TODO: the API does not include any signature
// XXX: We don't model all fields in the response, e.g. "PrevChainHash" is omitted.
// TODO: infinite loop troubles -- interestingly they (1) started with 37fef0168617 and (2) occur when proving Executability_Query ???
rule VerifyEpoch_2[color=#f9d949]:
    [ In(<'ve1', %epoch_id_verify>)
    , !SST_Epoch(%epoch_id_verify, chainhash_verify, roothash_verify, sig)
    ]//, St_Server(id, sk, latest_epoch_id) ]
    -->
    //[ St_Server(id, sk, latest_epoch_id)
    [ Out(<'ve2', chainhash_verify, roothash_verify>) ]

// Note: This algorithm does NOT check append-only-ness.
//       It only checks that chainhash_t is included in CT.
//       The real implementation does this using SCTs.
//       Note that this does NOT detect equivocation - a separate audit of CT is needed.
// TODO: model certificate and SCT.
rule VerifyEpoch_3[color=#f9d949]:
    let chainhash_new_computed = h(chainhash_old ++ roothash_new)
    in
    [ In(<'ve2', chainhash_new, roothash_new>)
    , !CT(epoch_id_new, chainhash_ct, sig)
    , St_Auditor_VerifyEpoch1(id, epoch_id_old, chainhash_old, epoch_id_new) ]
    --[
        Eq(chainhash_new_computed, chainhash_new)
      , Eq(chainhash_new, chainhash_ct)
      , EpochVerified(epoch_id_new, chainhash_new)
    ]->
    [ St_Auditor(id, epoch_id_new, chainhash_new) ]


/* ------- Audit CT ------- */

rule Audit_CT_Equivocation[color=#eb508d]:
    [ !CT(epoch_id, chainhash_ct_1, sig_1)
    , !CT(epoch_id, chainhash_ct_2, sig_2)
    , !Pk($server, pk) ]
    --[
        Neq(chainhash_ct_1, chainhash_ct_2)
      , Eq(verify(sig_1, <epoch_id, chainhash_ct_1>, pk), true)
      , Eq(verify(sig_2, <epoch_id, chainhash_ct_2>, pk), true)
      , EquivocationInCt(epoch_id)
    ]->
    []


/* ------- Executability (sanity check) Lemmas ------- */

// Tell Tamarin where "keys" could have come from
// TODO: doesn't work, still 9 partial deconstructions left
// TODO: use subterms??
// lemma Type_ClientKeyGen_Keys [use_induction,sources]:
//     all-traces
//     "All email prevkeylist newkeylist #i .
//         ClientKeyGen(email, prevkeylist, newkeylist)@i
//       ==> ( Ex prevprevkeylist #j . ClientKeyGen(email, prevprevkeylist, prevkeylist)@j & j < i )
//          | ( prevkeylist = 'empty')
//     "

lemma Executability_PublishEpoch:
    exists-trace
    "Ex email keys epoch_id chainhash #i #j .
        RequestInsertion(email, keys)@i
        & IssueEpochForInsertion(epoch_id, chainhash, email, keys)@j
        & i < j
    "

lemma Executability_VerifyEpoch:
    exists-trace
    "Ex epoch_id email keys chainhash #i #j .
        IssueEpochForInsertion(epoch_id, chainhash, email, keys)@i
        & EpochVerified(epoch_id, chainhash)@j
        & i < j
        & not (Ex #k . Adverserial_CT_Insert(epoch_id)@k )
    "

lemma Executability_ServerSignsOnlyOneChainhashPerEpochId:
    all-traces
    "All id epoch_id sig_1 #i .
        ServerEpochSign(id, epoch_id, sig_1)@i
    ==> not (Ex sig_2 #j . ServerEpochSign(id, epoch_id, sig_2)@j & not (sig_1 = sig_2))
    "

/* ------- Security Lemmas ------- */

// Helper needed to prove "Security_NonDiscreditabilityCT"
//
// Intuition:
// During "Security_NonDiscreditabilityCT" Tamarin searches a path where it creates many
// different servers, which then generate signatures and CT entries.
// By linking the ServerEpochSign to the InitServer, we implicitly link
// the signing back to a secret key.
// This helps Tamarin figure out that this is a dead-end:
// after all, the rule "Audit_CT_Equivocation" requires that they are signed by the same key.
lemma Helper_LinkEpochSignToInitServer[use_induction,reuse]:
    all-traces
    "All id e s #i .
        ServerEpochSign(id, e, s)@i
    ==> (InitServer(id)@i)
        | (Ex #j . InitServer(id)@j & j < i)
    "

lemma Security_NonDiscreditabilityCT:
    all-traces
    "All epoch_id #i . EquivocationInCt(epoch_id)@i
        ==> Ex #j . RevealServerSk()@j & j < i
    "
