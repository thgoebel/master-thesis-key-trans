/*
This file contains the VKD.KeyHistory and VKD.VerifyHistory subprotocols
(also known as ProtonVKD.SelfAudit).
*/

// Get the "latest" epoch
// TODO: we don't need to check that this is the latest epoch, do we? at least for modeling purposes?
rule SelfAudit_Start[color=#66deb1]:
    [ !St_Client(id, %clientrev, email, keys, %last_verified_rev, unverified_keys)
    , In(%epoch_id)
    , In(roothash_claimed)
    , Fr(~id_sa) ]
    --[
        SelfAuditStart(~id_sa)
      , UseStClient(id, %clientrev)
    ]->
    [ St_VerifyEpoch_Start(~id_sa, %epoch_id, roothash_claimed)
    , St_SelfAudit_1(id, %clientrev, email, keys, %last_verified_rev, unverified_keys, ~id_sa, %epoch_id, roothash_claimed) ]

// Get the key history + verify the inclusion proof towards the roothash
rule SelfAudit_LoopStart[color=#66deb1]:
    let user_tree = <email, key_revisions_claimed>
        roothash_computed = h( < head, h(user_tree), tail > )
    in
    [ St_VerifyEpoch_End(id_sa)
    , St_SelfAudit_1(id, %clientrev, email, keys, %last_verified_rev, unverified_keys, id_sa, %epoch_id, roothash)
    , In(head)
    , In(tail)
    , In(%highest_rev)
    , In(key_revisions_claimed)
    ]
    --[
        // SelfAudit_Ok(id, email, keys, %epoch_id)
        Eq(roothash_computed, roothash)
      , SelfAudit_LoopStart(id_sa, %highest_rev)
        // TODO: check (== restrict) that $label is not a subterm of head nor tail (== unique leaf)
    ]->
    [ St_SelfAudit_Loop(id_sa, email, %highest_rev, unverified_keys, key_revisions_claimed)
    , St_Self_Audit_2(id, %clientrev, email, keys, %last_verified_rev, id_sa, %epoch_id, roothash, %highest_rev) ]

// Check that the inclusion proof contains all the expected keys at all expected revisions
rule SelfAudit_Loop[color=#66deb1]:
    let curr_rev = %next_rev %+ %1
    in
    [ St_SelfAudit_Loop(id_sa, email, curr_rev, <val, unverified_keys>, < <curr_rev, val>, proof_rest >) ]
    --[
        SelfAudit_Loop(id_sa, curr_rev)
      , SelfAuditVal(id_sa, email, val, curr_rev)
    ]->
    [ St_SelfAudit_Loop(id_sa, email, %next_rev, unverified_keys, proof_rest) ]

// Finish and store the new latest_verified_rev
rule SelfAudit_End[color=#66deb1]:
    [ St_SelfAudit_Loop(id_sa, email, %current_rev, 'empty', proof_rest)
    , St_Self_Audit_2(id, %clientrev, email, keys, %last_verified_rev, id_sa, %epoch_id, roothash, %highest_rev) ]
    --[
        SelfAuditVerified(id, id_sa, email, %epoch_id, roothash)
      , Eq(%last_verified_rev, %current_rev)
      , StClientGen(id, %clientrev %+ %1)
    ]->
    [ !St_Client(id, %clientrev %+ %1, email, keys, %highest_rev, 'empty') ]


// TODO: add rule for selfaudit to fail. can we prove that it never fails if the server is honest (non-discreditability)?


/* ------- Executability (sanity check) Lemmas ------- */

lemma Executability_SelfAudit_Basic:
    exists-trace
    "Ex id id_sa email epoch_id roothash #i .
        SelfAuditVerified(id, id_sa, email, epoch_id, roothash)@i
    "
