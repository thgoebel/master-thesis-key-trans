theory ProtonKT
begin

/*
 * Protocol:    Proton Key Transparency
 * Modeler:     Thore Goebel
 * License:     GPL-v3-or-later
 * Date:        September/October 2023
 *
 * Status:      WIP
 */

builtins: hashing, natural-numbers, asymmetric-encryption, signing

heuristic: O "oracle.py"

/*
# ProtonKT model

This model is inspired by the TreeKEM model in [CSF23].

We model Certificate Transparency through persistent facts !CT
that both the server and the adversary can write,
and the clients and the auditor can read.

## Hash tree model

First, recall that <a, b, c> is synactic sugar for <a, <b, c>>.

### The upper tree

roothash = h( <'head', h(ut_0), ..., h(ut_i-1), h(ut_i), h(ut_i+1), ..., h(ut_n), 'tail'> )

This enables inclusion proofs for ut_i,
by providing the list of head hashes, list of tail hashes, and the user tree ut_i.
'head' and 'tail' are helpers to make pattern matching simpler.
TODO: we need to restrict that the location of ut_i is unique!

### The lower user subtrees

A user subtree ut has the following form:

ut = < $label, <%n, val_n>, ..., <%3, val_3>, <%2, 'empty'>, 'rest' >

Some examples:

< $label,   <%rev, val>,                rest     >
< $label, < <%rev, val>,                rest   > >    // same but rewritten
< $label, < <%rev, val>, < <%rev, val>, rest > > >    // two values/revisions

This allows querying to simply return:

ut = <$label, <%n, val_n>, rest>

TODO: we don't really need the %rev in the tree, it is implicit from the ordered list

## Limitations

Intentional modeling simplifications are noted as XXX.
Ideas for future modeling improvements are noted as TODO.

## References

[CSF23]: https://eprint.iacr.org/2022/1130
*/


/* ------- Initialisation Rules ------- */

// TODO: support multiple email addresses per account as tuples of <email, keylist>
//
// Note:
// The first "key" (== the empty key) has revision 2 because we need
// the last_verified_rev to be strictly lower. This ensures that the client
// can do a self-audit where it will see the "key" with revision 2.
// An implementation could simply initialise last_verified_rev = -1.
rule Init_Client:
    let keys = < <%1 %+ %1, 'empty'>, 'rest' >
        last_verified_rev = %1
        unverified_keys = 'empty'
    in
    [ Fr(~id) ]
    --[
        InitClient(~id)
      , StClientGen(~id, %1)
    ]->
    [ !St_Client(~id, %1, $email, keys, last_verified_rev, unverified_keys) ]

// !St_Client is a persistent fact so that it is reusable from the old in case a self-audit fails
restriction UseMaxStClient:
    "All id rev rev_ #t #t_ .
        UseStClient(id, rev)@t & StClientGen(id, rev_)@t_ & #t_ < #t
        ==>
        (rev_ << rev | rev_ = rev)
    "


rule Register_Server_Pk:
    [ Fr(~sk) ] --> [ !LtkServer($server, ~sk), !Pk($server, pk(~sk)), Out(pk(~sk)) ]

rule Reveal_Server_Sk:
    [ !LtkServer(server, sk) ] --[ RevealServerSk() ]-> [ Out(sk) ]

// rule Init_Server:
//     let epoch_id = %1
//         latest_epoch_id = epoch_id
//         roothash = 'empty'
//         chainhash = 'empty'
//         sig = sign(<epoch_id, chainhash>, sk)
//     in
//     [ Fr(~id)
//     , !LtkServer(server, sk) ]
//     --[
//         InitServer(~id)
//       , OnlyOne('server')
//       , IssueEpoch(epoch_id, chainhash)
//       , ServerEpochSign(~id, epoch_id, sig)
//     ]->
//     [ St_Server(~id, sk, latest_epoch_id)
//     , !CT(epoch_id, chainhash, sig)
//     , !SST_Epoch(epoch_id, chainhash, roothash, sig) ]


/* ------- Various Protocol Rules ------- */

// Anyone can insert into CT. Only upong CT audits the signature will be checked.
rule CT_Insert:
    [ In(<epoch_id, chainhash, sig>) ]
    --[
        CtInsertChainhash(epoch_id, chainhash)
    ]->
    [ !CT(epoch_id, chainhash, sig) ]


/* ------- Subprotocol Rules ------- */

#include "publishepoch.spthy"
#include "verifyepoch.spthy"
#include "query.spthy"
#include "selfaudit.spthy"
#include "appendaudit.spthy"


/* ------- Restrictions ------- */

restriction Eq:
    "All a b #i . Eq(a,b)@i ==> a = b"

restriction Neq:
    "All a b #i . Neq(a,b)@i ==> not (a = b)"

// The "not" part isn't needed, but let's make it explicit.
restriction StrictlyGreaterThan: // x > y
    "All x y #i . StrictlyGreaterThan(x,y)@i ==> y << x & not (x = y)"

// restriction StrictlyLessThan: // x < y
//     "All x y #i . StrictlyLessThan(x,y)@i ==> x << y & not (x = y)"

// restriction GreaterOrEqualThan: // x >= y
//     "All x y #i . GreaterOrEqualThan(x,y)@i ==> y << x | x = y"

// restriction LessOrEqualThan: // x <= y
//     "All x y #i . LessOrEqualThan(x,y)@i ==> x << y | x = y"

// restriction OnlyOne:
//     "All a #i #j . OnlyOne(a)@i & OnlyOne(a)@j ==> #i = #j"


/* ------- Lemmas ------- */

// TODO: lemma that there is only one SelfAuditVal for each revision

// lemma If_SelfAudit_LastVerifiedRev_then_all_previous_revs_were_seen[reuse,use_induction]:
//     "All id_c id_sa1 rev highest_rev rev #j .
//           SelfAuditVerifiedLastVerifiedRev(id_c, id_sa1, highest_rev)@j
//         & ( rev << highest_rev | rev = highest_rev )
//     ==>
//         Ex id_sa2 label val #i . SelfAuditVal(id_c, id_sa2, label, val, rev)@i & i < j
//     "

lemma Same_Roothash_Implies_Same_Values[reuse]:
    "All label roothash
        val_q rev_q ep_q #q
        id_c id_sa1 ep_s #s1
        .
          QueryVerifiedEpHash(label, val_q, rev_q, ep_q, roothash)@q
        & SelfAuditVerified(id_c, id_sa1, label, ep_s, roothash)@s1
        // & ( ep_q << ep_s | ep_q = ep_s )
    ==>
        Ex id_sa2 val_s rev_s #s2
            .
              SelfAuditVal(id_c, id_sa2, label, val_s, rev_s)@s2
            & s2 < s1
            & val_q = val_s
            & rev_q = rev_s
    "

lemma RootHashChainQ[reuse]:
    "All label val_q rev_q ep_q roothash_q #q
        id_a ep_a ch_a roothash_a #a.
              QueryVerifiedEpHash(label, val_q, rev_q, ep_q, roothash_q)@q
            & AppendAudit(id_a, ep_a, roothash_a, ch_a)@a
            & ( ep_q << ep_a | ep_q = ep_a )
        ==> ( (roothash_q << ch_a & roothash_a << ch_a)
            | (
                ( Ex ep_e chainhash chainhash_ #e #e_ .
                    CtInsertChainhash(ep_e, chainhash)@e
                    & CtInsertChainhash(ep_e, chainhash_)@e_
                    & not ( chainhash = chainhash_ )
                    & ( ep_e << ep_a | ep_e = ep_a )
                )
            ))"

lemma RootHashChainSA[reuse]:
    "All ep_s id_c id_sa1 label roothash_s #s
        id_a ep_a ch_a roothash_a #a.
              SelfAuditVerified(id_c, id_sa1, label, ep_s, roothash_s)@s
            & AppendAudit(id_a, ep_a, roothash_a, ch_a)@a
            & ( ep_s << ep_a | ep_s = ep_a )
        ==> ( (roothash_s << ch_a & roothash_a << ch_a)
            | (
                ( Ex ep_e chainhash chainhash_ #e #e_ .
                    CtInsertChainhash(ep_e, chainhash)@e
                    & CtInsertChainhash(ep_e, chainhash_)@e_
                    & not ( chainhash = chainhash_ )
                    & ( ep_e << ep_a | ep_e = ep_a )
                )
            ))"

// All Queries BEFORE the SelfAudit should be consistent
// (with the SelfAudit, but also with each other).
// TODO: depends on roothashes/chainhashes
lemma Sec_Consistency:
    "All label
        val_q rev_q ep_q roothash_q #q
        ep_s id_c id_sa1 roothash_s #s1
        id_a ep_a roothash_a chainhash_a #a
        .

        QueryVerifiedEpHash(label, val_q, rev_q, ep_q, roothash_q)@q

          & SelfAuditVerified(id_c, id_sa1, label, ep_s, roothash_s)@s1
          // only for all queries in epochs up to the SelfAudit
          & ( ep_q << ep_s | ep_q = ep_s )

          // and there was an append-only-audit concluding at the same roothash
          & AppendAudit(id_a, ep_a, roothash_a, chainhash_a)@a
          & ( ep_s << ep_a | ep_s = ep_a )

        ==>
        // Case 1: roothashes are equal
        //         then we want security:
        //         i.e. SOME previous self-audit saw this key as well
        //         (this may be different from the Self-Audit above)
        (
            // roothash_q = roothash_s
            // ==>
            ( Ex id_sa2 val_s rev_s #s2 .
                SelfAuditVal(id_c, id_sa2, label, val_s, rev_s)@s2
                & s2 < s1
                // the value + revision are consistent
                & val_q = val_s
                & rev_q = rev_s
            )
        )
        // TODO: and no self-audit saw a different key?

        // or an auditor raised a warning for append-only-ness
        // | ( Ex . )

        // Case 2: roothashes are NOT equal
        //         then we want this to be detected
        // TODO: and the offending epoch was inserted BEFORE the querying??
        | (
            // not ( roothash_q = roothash_s)
            // ==>
            ( Ex ep_e chainhash chainhash_ #e #e_ .
                  CtInsertChainhash(ep_e, chainhash)@e
                & CtInsertChainhash(ep_e, chainhash_)@e_
                & not ( chainhash = chainhash_ )
                & ( ep_e << ep_q | ep_e = ep_q )
            )
        )
    "

end


/*
induction:
if it holds now, adding a user does not break the loop
*/
