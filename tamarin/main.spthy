theory ProtonKT
begin

/*
 * Protocol:    Proton Key Transparency
 * Modeler:     Thore Goebel
 * License:     GPL-v3-or-later
 * Date:        September/October 2023
 *
 * Status:      WIP
 */

builtins: hashing, multiset, natural-numbers, asymmetric-encryption, signing

/*
This model is inspired by the TreeKEM model in [CSF23].

The persistent facts prefixed by "SST_" are "Server State"
and they should only be used by server rules.

We model Certificate Transparency through persistent facts !CT
that both the server and the adversary can write,
and the the auditor can read.

We model the KT tree as persitent facts !TreeLeaf.
When !TreeLeaf appears in the premise of a rule, applying this rule
implicitly means that the inclusion proof for this leaf has been checked
(i.e. the co-path from the leaf to the root).

## Limitations

See the various TODOs throughout.

## References

[CSF23]: https://eprint.iacr.org/2022/1130
*/


/* ------- Initialisation Rules ------- */

// TODO: support multiple email per account as tuples of <email, keylist>
rule Init_Client:
    let keys = 'empty'
        keys_rev = %1
    in
    [ Fr(~id) ] --> [ St_Client(~id, $email, keys, keys_rev) ]

rule Register_Server_Pk:
    [ Fr(~sk) ] --> [ !LtkServer($server, ~sk), !Pk($server, pk(~sk)), Out(pk(~sk)) ]

rule Reveal_Server_Sk:
    [ !LtkServer(server, sk) ] --[ RevealServerSk() ]-> [ Out(sk) ]

rule Init_Server:
    let epoch_id = %1
        latest_epoch_id = epoch_id
        roothash = 'empty'
        chainhash = 'empty'
        sig = sign(<epoch_id, chainhash>, sk)
    in
    [ Fr(~id)
    , !LtkServer(server, sk) ]
    --[
        InitServer(~id)
      , OnlyOne('server')
      , IssueEpoch(epoch_id, chainhash)
      , ServerEpochSign(~id, epoch_id, sig)
    ]->
    [ St_Server(~id, sk, latest_epoch_id)
    , !CT(epoch_id, chainhash, sig)
    , !SST_Epoch(epoch_id, chainhash, roothash, sig) ]

rule Init_Auditor:
    let epoch_id = %1
        chainhash = 'empty'
    in
    [ Fr(~id) ] --> [ St_Auditor(~id, epoch_id, chainhash) ]


/* ------- Various Protocol Rules ------- */

rule Adverserial_CT_Insert:
    [ In(<epoch_id, chainhash, sig>) ]
    --[
        Adverserial_CT_Insert(epoch_id)
      , Adverserial_CT_Sig(sig)
    ]->
    [ !CT(epoch_id, chainhash, sig) ]


/* ------- Subprotocol Rules ------- */

#include "publishepoch.spthy"
#include "verifyepoch.spthy"
#include "query.spthy"
#include "selfaudit.spthy"


/* ------- Restrictions ------- */

restriction Eq:
    "All a b #i . Eq(a,b)@i ==> a = b"

restriction Neq:
    "All a b #i . Neq(a,b)@i ==> not (a = b)"

// The "not" part isn't needed, but let's make it explicit.
// restriction StrictlyGreaterThan: // x > y
//     "All x y #i . StrictlyGreaterThan(x,y)@i ==> y << x & not (x = y)"

// restriction StrictlyLessThan: // x < y
//     "All x y #i . StrictlyLessThan(x,y)@i ==> x << y & not (x = y)"

// restriction GreaterOrEqualThan: // x >= y
//     "All x y #i . GreaterOrEqualThan(x,y)@i ==> y << x | x = y"

restriction LessOrEqualThan: // x <= y
    "All x y #i . LessOrEqualThan(x,y)@i ==> x << y | x = y"

restriction OnlyOne:
    "All a #i #j . OnlyOne(a)@i & OnlyOne(a)@j ==> #i = #j"


/* ------- Lemmas ------- */

// TODO

end
