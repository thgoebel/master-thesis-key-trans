theory ProtonKT
begin

/*
 * Protocol:    Proton Key Transparency
 * Modeler:     Thore Goebel
 * License:     GPL-v3-or-later
 * Date:        September/October 2023
 *
 * Status:      WIP
 */

builtins: hashing, natural-numbers, asymmetric-encryption, signing

/*
This model is inspired by the TreeKEM model in [CSF23].

We model Certificate Transparency through persistent facts !CT
that both the server and the adversary can write,
and the the auditor can read.

## Limitations

Intentional modeling simplifications are noted as XXX.
Ideas for future modeling improvements are noted as TODO.

## References

[CSF23]: https://eprint.iacr.org/2022/1130
*/


/* ------- Initialisation Rules ------- */

// TODO: support multiple email per account as tuples of <email, keylist>
rule Init_Client:
    let keys = < <%1, 'empty'>, 'rest'>
    in
    [ Fr(~id) ] --> [ St_Client(~id, $email, keys) ]

rule Register_Server_Pk:
    [ Fr(~sk) ] --> [ !LtkServer($server, ~sk), !Pk($server, pk(~sk)), Out(pk(~sk)) ]

rule Reveal_Server_Sk:
    [ !LtkServer(server, sk) ] --[ RevealServerSk() ]-> [ Out(sk) ]

// rule Init_Server:
//     let epoch_id = %1
//         latest_epoch_id = epoch_id
//         roothash = 'empty'
//         chainhash = 'empty'
//         sig = sign(<epoch_id, chainhash>, sk)
//     in
//     [ Fr(~id)
//     , !LtkServer(server, sk) ]
//     --[
//         InitServer(~id)
//       , OnlyOne('server')
//       , IssueEpoch(epoch_id, chainhash)
//       , ServerEpochSign(~id, epoch_id, sig)
//     ]->
//     [ St_Server(~id, sk, latest_epoch_id)
//     , !CT(epoch_id, chainhash, sig)
//     , !SST_Epoch(epoch_id, chainhash, roothash, sig) ]


/* ------- Various Protocol Rules ------- */

// Anyone can insert into CT. Only upong CT audits the signature will be checked.
rule CT_Insert:
    [ In(<epoch_id, chainhash, sig>) ]
    -->
    [ !CT(epoch_id, chainhash, sig) ]


/* ------- Subprotocol Rules ------- */

#include "publishepoch.spthy"
#include "verifyepoch.spthy"
#include "query.spthy"
#include "selfaudit.spthy"


/* ------- Restrictions ------- */

restriction Eq:
    "All a b #i . Eq(a,b)@i ==> a = b"

restriction Neq:
    "All a b #i . Neq(a,b)@i ==> not (a = b)"

// The "not" part isn't needed, but let's make it explicit.
// restriction StrictlyGreaterThan: // x > y
//     "All x y #i . StrictlyGreaterThan(x,y)@i ==> y << x & not (x = y)"

// restriction StrictlyLessThan: // x < y
//     "All x y #i . StrictlyLessThan(x,y)@i ==> x << y & not (x = y)"

// restriction GreaterOrEqualThan: // x >= y
//     "All x y #i . GreaterOrEqualThan(x,y)@i ==> y << x | x = y"

// restriction LessOrEqualThan: // x <= y
//     "All x y #i . LessOrEqualThan(x,y)@i ==> x << y | x = y"

restriction OnlyOne:
    "All a #i #j . OnlyOne(a)@i & OnlyOne(a)@j ==> #i = #j"


/* ------- Lemmas ------- */

// TODO

end
