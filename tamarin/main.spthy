theory ProtonKT
begin

/*
 * Protocol:    Proton Key Transparency
 * Modeler:     Thore Goebel
 * License:     GPL-v3-or-later
 * Date:        September/October 2023
 *
 * Status:      WIP
 */

builtins: hashing, natural-numbers, asymmetric-encryption, signing

/*
# ProtonKT model

This model is inspired by the TreeKEM model in [CSF23].

We model Certificate Transparency through persistent facts !CT
that both the server and the adversary can write,
and the clients and the auditor can read.

## Hash tree model

First, recall that <a, b, c> is synactic sugar for <a, <b, c>>.

### The upper tree

roothash = h( <'head', h(ut_0), ..., h(ut_i-1), h(ut_i), h(ut_i+1), ..., h(ut_n), 'tail'> )

This enables inclusion proofs for ut_i,
by providing the list of head hashes, list of tail hashes, and the user tree ut_i.
'head' and 'tail' are helpers to make pattern matching simpler.
TODO: we need to restrict that the location of ut_i is unique!

### The lower user subtrees

A user subtree ut has the following form:

ut = < $label, <%n, val_n>, ..., <%2, val_2>, <%1, 'empty'>, 'rest' >

Some examples:

< $label,   <%rev, val>,                rest     >
< $label, < <%rev, val>,                rest   > >    // same but rewritten
< $label, < <%rev, val>, < <%rev, val>, rest > > >    // two values/revisions

This allows querying to simply return:

ut = <$label, <%n, val_n>, rest>

TODO: we don't really need the %rev in the tree, it is implicit from the ordered list

## Limitations

Intentional modeling simplifications are noted as XXX.
Ideas for future modeling improvements are noted as TODO.

## References

[CSF23]: https://eprint.iacr.org/2022/1130
*/


/* ------- Initialisation Rules ------- */

// TODO: support multiple email addresses per account as tuples of <email, keylist>
rule Init_Client:
    let keys = < <%1, 'empty'>, 'rest' >
        last_verified_rev = %1
        unverified_keys = 'empty'
    in
    [ Fr(~id) ]
    --[ InitClient(~id) ]->
    [ St_Client(~id, $email, keys, last_verified_rev, unverified_keys) ]

rule Register_Server_Pk:
    [ Fr(~sk) ] --> [ !LtkServer($server, ~sk), !Pk($server, pk(~sk)), Out(pk(~sk)) ]

rule Reveal_Server_Sk:
    [ !LtkServer(server, sk) ] --[ RevealServerSk() ]-> [ Out(sk) ]

// rule Init_Server:
//     let epoch_id = %1
//         latest_epoch_id = epoch_id
//         roothash = 'empty'
//         chainhash = 'empty'
//         sig = sign(<epoch_id, chainhash>, sk)
//     in
//     [ Fr(~id)
//     , !LtkServer(server, sk) ]
//     --[
//         InitServer(~id)
//       , OnlyOne('server')
//       , IssueEpoch(epoch_id, chainhash)
//       , ServerEpochSign(~id, epoch_id, sig)
//     ]->
//     [ St_Server(~id, sk, latest_epoch_id)
//     , !CT(epoch_id, chainhash, sig)
//     , !SST_Epoch(epoch_id, chainhash, roothash, sig) ]


/* ------- Various Protocol Rules ------- */

// Anyone can insert into CT. Only upong CT audits the signature will be checked.
rule CT_Insert:
    [ In(<epoch_id, chainhash, sig>) ]
    -->
    [ !CT(epoch_id, chainhash, sig) ]


/* ------- Subprotocol Rules ------- */

#include "publishepoch.spthy"
#include "verifyepoch.spthy"
#include "query.spthy"
#include "selfaudit.spthy"
#include "appendaudit.spthy"


/* ------- Restrictions ------- */

restriction Eq:
    "All a b #i . Eq(a,b)@i ==> a = b"

restriction Neq:
    "All a b #i . Neq(a,b)@i ==> not (a = b)"

// The "not" part isn't needed, but let's make it explicit.
// restriction StrictlyGreaterThan: // x > y
//     "All x y #i . StrictlyGreaterThan(x,y)@i ==> y << x & not (x = y)"

// restriction StrictlyLessThan: // x < y
//     "All x y #i . StrictlyLessThan(x,y)@i ==> x << y & not (x = y)"

// restriction GreaterOrEqualThan: // x >= y
//     "All x y #i . GreaterOrEqualThan(x,y)@i ==> y << x | x = y"

// restriction LessOrEqualThan: // x <= y
//     "All x y #i . LessOrEqualThan(x,y)@i ==> x << y | x = y"

restriction OnlyOne:
    "All a #i #j . OnlyOne(a)@i & OnlyOne(a)@j ==> #i = #j"


/* ------- Lemmas ------- */

// TODO

end
