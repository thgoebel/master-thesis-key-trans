/*
This file contains the VKD.Query and VKD.VerifyQuery subprotocols
(also known as ProtonVKD.GetProof and ProtonVKD.VerifyProofInEpoch).
*/

// We have no rules that explicitly model the server - the network adversary/Tamarin's contraint solver will do it for us.


/* ------- VKD.Query / ProtonVKD.GetProof ------- */

// Simulate the (response to the) REST-API call
// curl -H 'x-pm-uid: XXXXX' -H 'Cookie: AUTH-XXXXX;' -H 'x-pm-appversion: web-mail@5.0.28.10' "https://mail.proton.me/api/kt/v1/epochs/300/proof/hello@thore.io/1" | jq
// i.e. in reality the client chooses %epoch_id, $label, %rev!
rule Query_1[color=#c4b7ff]:
    [ Fr(~id)
    , In(<%epoch_id, roothash>)
    , In(<val, %rev>)
    ]
    // TODO: should Query() and QueryVerified() contain the query-id?
    --[ Query($label) ]->
    // Call out to ProtonVKD.VerifyEpoch (inside the VerifyQuery subprotocol).
    [ St_VerifyEpoch_Start(~id, %epoch_id, roothash)
    , St_Query_1(~id, $label, val, %rev, %epoch_id, roothash) ]


/* ------- VKD.VerifyQuery / ProtonVKD.VerifyProofInEpoch ------- */

/* ------- ProtonVKD.VerifyProof ------- */

// Check the copath to roothash, i.e. the inclusion/absence proof
// Note that our model guarantees that %rev is the latest revision.
// In practice, we need to check this!
rule VerifyQuery_1[color=#c4b7ff]:
    let user_tree = < $label, <%rev, val>, rest >
        roothash_computed = h( < head, h(user_tree), tail > )
    in
    [ St_VerifyEpoch_End(id)
    , St_Query_1(id, $label, val, %rev, %epoch_id, roothash)
    , In(rest), In(head), In(tail) // models the `Neighbours` fields in the API reponse
    // TODO: model the `Verifier` field to prove uniqueness within the list
    ]
    --[
        QueryVerified($label, val, %rev, roothash)
      , Eq(roothash_computed, roothash)
        // TODO: check minEpochId
        // TODO: check SKL signature
    ]->
    []




/* ------- Security Lemmas ------- */

// lemma Helper_Ordering_QueryVerified [reuse]:
//     all-traces
//     "All epoch_id label val rev roothash #i .
//         QueryVerified(epoch_id, label, val, rev, roothash)@i
//         ==>
//         (Ex #j . Insert(label, val, rev)@j & j < i )
//     "

// XXX: no outcome type, i.e. only inclusion for now (no absence/obsolence)
lemma QueryConsistency:
    all-traces
    "All label val1 rev1 val2 rev2 roothash1 roothash2 #i1 #i2 .
          QueryVerified(label, val1, rev1, roothash1)@i1
        & QueryVerified(label, val2, rev2, roothash2)@i2
        & roothash1 = roothash2
        & not (Ex #r . RevealServerSk()@r & r < i1 & r < i2)
        ==>
          val1 = val2
        & rev1 = rev2
    "
