/*
This file contains the VKD.Query and VKD.VerifyQuery subprotocols
(also known as ProtonVKD.GetProof and ProtonVKD.VerifyProofInEpoch).
*/


/* ------- VKD.Query / ProtonVKD.GetProof ------- */

// Simulate the REST-API call
// curl -H 'x-pm-uid: XXXXX' -H 'Cookie: AUTH-XXXXX;' -H 'x-pm-appversion: web-mail@5.0.28.10' "https://mail.proton.me/api/kt/v1/epochs/300/proof/hello@thore.io/1" | jq
rule Query_1[color=#c4b7ff]:
    [ St_Client(id, email, keys, keys_rev)
    , In(%epoch_id) ] // workaround to get *a* epoch_id in the premise
    --[ Query($label) ]->
    [ St_Client_Query1(id, email, keys, keys_rev, $label, %epoch_id)
    , Out(<$label, %epoch_id>) ]

// ... no rules that explicitly model the server - the network adversary/Tamarin's contraint solver will do it for us ...

rule Query_2[color=#c4b7ff]:
    [ St_Client_Query1(id, email, keys, keys_rev, label, epoch_id)
    , In(<val, rev, roothash>) ]
    -->
    [ St_Client_Query_Done(id, email, keys, keys_rev, label, epoch_id, val, rev, roothash) ]


/* ------- VKD.VerifyQuery / ProtonVKD.VerifyProofInEpoch ------- */

rule VerifyQuery_0[color=#f9d949]:
    let call_stack = <'query_verify_epoch', label, val, rev>
    in
    [ St_Client_Query_Done(id, email, keys, keys_rev, label, epoch_id, val, rev, roothash) ]
    -->
    // Call out to ProtonVKD.VerifyEpoch (inside the Query subprotocol).
    [ St_Client_VerifyEpoch0(id, email, keys, keys_rev, epoch_id, roothash, call_stack) ]


/* ------- ProtonVKD.VerifyProof ------- */

// Check the copath to roothash, i.e. the inclusion/absence proof
rule VerifyQuery_1[color=#f9d949]:
    let call_stack = <'query_verify_epoch', $label, val, %rev>
        user_tree = < $label, <%rev, val>, rest >
        roothash_computed = h( < head, h(user_tree), tail > )
    in
    [ St_Client_VerifyEpoch_Done(id, email, keys, keys_rev, epoch_id, roothash, call_stack)
    , In(rest), In(head), In(tail) // models the `Neighbours` fields in the API reponse
    // TODO: model the `Verifier` field to prove uniqueness within the list
    ]
    --[
        QueryVerified($label, val, %rev, roothash)
      , Eq(roothash_computed, roothash)
        // TODO: check minEpochId
        // TODO: check SKL signature
    ]->
    [ St_Client(id, email, keys, keys_rev) ]




/* ------- Security Lemmas ------- */

// lemma Helper_Ordering_QueryVerified [reuse]:
//     all-traces
//     "All epoch_id label val rev roothash #i .
//         QueryVerified(epoch_id, label, val, rev, roothash)@i
//         ==>
//         (Ex #j . Insert(label, val, rev)@j & j < i )
//     "

// XXX: no outcome type, i.e. only inclusion for now (no absence/obsolence)
lemma QueryConsistency:
    all-traces
    "All label val1 rev1 val2 rev2 roothash1 roothash2 #i1 #i2 .
          QueryVerified(label, val1, rev1, roothash1)@i1
        & QueryVerified(label, val2, rev2, roothash2)@i2
        & roothash1 = roothash2
        & not (Ex #r . RevealServerSk()@r & r < i1 & r < i2)
        ==>
          val1 = val2
        & rev1 = rev2
    "
