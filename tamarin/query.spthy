/*
This file contains the VKD.Query and VKD.VerifyQuery subprotocols
(also known as ProtonVKD.GetProof and ProtonVKD.VerifyProofInEpoch).
*/

/* ------- VKD.Query / ProtonVKD.GetProof ------- */
// curl -H 'x-pm-uid: XXXXX' -H 'Cookie: AUTH-XXXXX;' -H 'x-pm-appversion: web-mail@5.0.28.10' "https://mail.proton.me/api/kt/v1/epochs/300/proof/hello@thore.io" | jq

rule Query_1[color=#c4b7ff]:
    [ St_Client(id, email, keys, keys_rev)
    , In(%epoch_id) ] // workaround to get *a* epoch_id in the premise
    -->
    [ St_Client_Query1(id, email, keys, keys_rev, $label, %epoch_id)
    , Out(<'q1', $label, %epoch_id>) ]

// TODO: this allows the server to reply with any val_rev. But it should reply with the latest one!
// TODO: what to do about this infinite loop? just keep St_Server commented out?
rule Query_2[color=#c4b7ff]:
    [ //St_Server(id, sk, latest_epoch_id)
     In(<'q1', label, epoch_id_query>)
    , !SST_Epoch(epoch_id_query, chainhash_query, roothash_query, sig)
    , !SST_Directory(label, epoch_id_inserted, val, val_rev) ]
    --[
        LessOrEqualThan(epoch_id_inserted, epoch_id_query)
      , QueryResponse(epoch_id_query, label, val)
    ]->
    [ //St_Server(id, sk, latest_epoch_id)
     Out(<'q2', val, val_rev, roothash_query>) ]

rule Query_3[color=#c4b7ff]:
    [ St_Client_Query1(id, email, keys, keys_rev, label, epoch_id)
    , In(<'q2', val, val_rev, roothash>) ]
    -->
    [ St_Client_Query_Done(id, email, keys, keys_rev, label, epoch_id, val, val_rev, roothash) ]


/* ------- VKD.VerifyQuery / ProtonVKD.VerifyProofInEpoch ------- */

rule VerifyQuery_0[color=#f9d949]:
    let stack = <'query_verify_epoch', label, val, val_rev>
    in
    [ St_Client_Query_Done(id, email, keys, keys_rev, label, epoch_id, val, val_rev, roothash) ]
    -->
    // Call out to ProtonVKD.VerifyEpoch (inside the Query subprotocol).
    [ St_Client_VerifyEpoch0(id, email, keys, keys_rev, epoch_id, roothash, stack) ]

rule VerifyQuery_1[color=#f9d949]:
    let stack_e = <'query_verify_epoch', label, val, val_rev>
    in
    [ St_Client_VerifyEpoch_Done(id, email, keys, keys_rev, epoch_id, roothash, stack_e)
    , !TreeLeaf(email, keys) // implicit ProtonVKD.VerifyProof call
    ]
    --[
        QueryVerified(epoch_id, label, val, val_rev, roothash)
        // TODO: check SKL signature
    ]->
    [ St_Client(id, email, keys, keys_rev) ]


/* ------- ProtonVKD.VerifyProof ------- */
// Checks the copath to roothash, i.e. the inclusion/absence proof

// XXX: This algorithm is not modeled explicitly.
//      It is implicit in using the !TreeLeaf fact,

/* ------- Lemmas ------- */

lemma Helper_Ordering [reuse]:
    all-traces
    "All epoch_id_query label val #i .
        QueryResponse(epoch_id_query, label, val)@i
     ==> (Ex #j . Insert(label, val)@j & j < i )
    "

lemma Executability_Query:
    exists-trace
    "Ex epoch_id label val val_rev roothash #i #j.
        QueryResponse(epoch_id, label, val)@i
        & QueryVerified(epoch_id, label, val, val_rev, roothash)@j
        & i < j
    "
