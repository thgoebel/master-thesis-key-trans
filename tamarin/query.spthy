/*
This file contains the VKD.Query and VKD.VerifyQuery subprotocols
(also known as ProtonVKD.GetProof and ProtonVKD.VerifyProofInEpoch).
*/

/* ------- VKD.Query / ProtonVKD.GetProof ------- */
// curl -H 'x-pm-uid: XXXXX' -H 'Cookie: AUTH-XXXXX;' -H 'x-pm-appversion: web-mail@5.0.28.10' "https://mail.proton.me/api/kt/v1/epochs/300/proof/hello@thore.io" | jq

rule Query_1[color=#c4b7ff]:
    [ St_Client(id, email, keys, keys_rev)
    , In(%epoch_id) ] // workaround to get *a* epoch_id in the premise
    -->
    [ St_Client_Query1(id, email, keys, keys_rev, $label, %epoch_id)
    , Out(<'q1', $label, %epoch_id>) ]

// TODO: what to do about this infinite loop? just keep St_Server commented out?
rule Query_2[color=#c4b7ff]:
    [ //St_Server(id, sk, latest_epoch_id)
     In(<'q1', label, epoch_id_query>)
    , !SST_Epoch(epoch_id_query, chainhash_query, roothash_query, sig)
    , !TreeLeaf(label, val, rev) ]
    --[
        QueryResponse(epoch_id_query, label, val, rev)
      , IsLatestRevision(label, rev)
    ]->
    [ //St_Server(id, sk, latest_epoch_id)
     Out(<'q2', val, rev, roothash_query>) ]

rule Query_3[color=#c4b7ff]:
    [ St_Client_Query1(id, email, keys, keys_rev, label, epoch_id)
    , In(<'q2', val, rev, roothash>) ]
    -->
    [ St_Client_Query_Done(id, email, keys, keys_rev, label, epoch_id, val, rev, roothash) ]


/* ------- VKD.VerifyQuery / ProtonVKD.VerifyProofInEpoch ------- */

rule VerifyQuery_0[color=#f9d949]:
    let stack = <'query_verify_epoch', label, val, rev>
    in
    [ St_Client_Query_Done(id, email, keys, keys_rev, label, epoch_id, val, rev, roothash) ]
    -->
    // Call out to ProtonVKD.VerifyEpoch (inside the Query subprotocol).
    [ St_Client_VerifyEpoch0(id, email, keys, keys_rev, epoch_id, roothash, stack) ]

rule VerifyQuery_1[color=#f9d949]:
    let stack_e = <'query_verify_epoch', label, val, rev>
    in
    [ St_Client_VerifyEpoch_Done(id, email, keys, keys_rev, epoch_id, roothash, stack_e)
    , !TreeLeaf(label, val, rev) // implicit ProtonVKD.VerifyProof call
    ]
    --[
        QueryVerified(epoch_id, label, val, rev, roothash)
      , IsLatestRevision(label, rev)
        // TODO: check minEpochId
        // TODO: check SKL signature
    ]->
    [ St_Client(id, email, keys, keys_rev) ]


/* ------- ProtonVKD.VerifyProof ------- */
// Checks the copath to roothash, i.e. the inclusion/absence proof

// XXX: This algorithm is not modeled explicitly.
//      It is implicit in using the !TreeLeaf fact,


/* ------- Executability Lemmas ------- */

lemma Executability_EpochVerified_to_IssueEpoch:
    all-traces
    "All epoch_id chainhash #i .
        EpochVerified(epoch_id, chainhash)@i
        ==>
          (Ex #j . IssueEpoch(epoch_id, chainhash)@j & j < i)
        | (Ex #j . Adverserial_CT_Insert(epoch_id)@j & j < i)
    "

lemma Helper_Ordering [reuse]:
    all-traces
    "All epoch_id_query label val rev #i .
        QueryResponse(epoch_id_query, label, val, rev)@i
     ==> (Ex #j . Insert(label, val, rev)@j & j < i )
    "

// TODO: This produces an unnecessarily long example trace
lemma Executability_Query:
    exists-trace
    "Ex epoch_id label val rev roothash #i #j #k .
          RequestInsertion(label, val)@i
        & QueryResponse(epoch_id, label, val, rev)@j
        & QueryVerified(epoch_id, label, val, rev, roothash)@k
        & i < j
        & j < k
    "


/* ------- Security Lemmas ------- */

lemma Helper_Ordering_QueryVerified [reuse]:
    all-traces
    "All epoch_id label val rev roothash #i .
        QueryVerified(epoch_id, label, val, rev, roothash)@i
        ==>
        (Ex #j . Insert(label, val, rev)@j & j < i )
    "

// XXX: no outcome type, i.e. only inclusion for now (no absence/obsolence)
lemma QueryConsistency:
    all-traces
    "All epoch_id label val1 rev1 val2 rev2 roothash1 roothash2 #i1 #i2 .
          QueryVerified(epoch_id, label, val1, rev1, roothash1)@i1
        & QueryVerified(epoch_id, label, val2, rev2, roothash2)@i2
        & roothash1 = roothash2
        ==>
          val1 = val2
        // TODO: the blows up
        & rev1 = rev2
    "
